// This work is provided under GPLv3, the GNU General Public License 3
//   http://www.gnu.org/licenses/gpl-3.0.html

// Prof. Dr. Carsten Vogt
// Technische Hochschule Köln, Germany
// Fakultät für Informations-, Medien- und Elektrotechnik
// carsten.vogt@th-koeln.de
// 15.10.2022

package de.thkoeln.cvogt.android.opengl_utilities;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.TypeEvaluator;
import android.animation.ValueAnimator;
import android.opengl.Matrix;
import android.util.Log;
import android.view.animation.Interpolator;
import android.view.animation.LinearInterpolator;

import java.util.ArrayList;

/**
 * Class with static convenience methods to create animators for shapes.
 * <P>
 * A method of this class will add a created animator to a shape, i.e. an object of class <I>GLShapeCV</I>, through its method <I>addAnimator()</I>.
 * The animator will be then be started automatically when the shape is added to a surface view, i.e. an object of class <I>GLSurfaceViewCV</I>.
 * The animator is then controlled by the implicit thread of the surface view.
 * <P>
 * As animation is based on the "property animation" technique provided by Android,
 * all methods of the Android Java class <I>ObjectAnimator</I> can be applied to the animators generated by the methods of this class
 * (e.g. <I>setInterpolator()</I> to assign a time interpolator to control the timing of the animator).
 * <P>
 * Currently, these animations are supported:
 * <UL>
 * <P><LI>Scaling, rotation, translation
 * <P><LI>Alignment with a vector or another shape
 * <P><LI>Placement between two given points in space
 * <P><LI>Circular movement around a given arc by a given angle
 * <P><LI>Spiral movement around a given arc
 * <P><LI>Movement along a Bezier curve
 * </UL>
 * <BR>
 * @see de.thkoeln.cvogt.android.opengl_utilities.GLShapeCV
 */

// TODO WEITERE ANIMATOREN - SIEHE DAZU AUCH METHODEN ADDXXXANIMATOR DER KLASSE ANIMATORGUIOBJECTCV IM PROJEKT UTILITIESPROPANIMCV

public class GLAnimatorFactoryCV {

    /**
     * Makes an animator to scale a given shape in the x dimension.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param scaleFactor The target scale factor of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorScaleX(GLShapeCV shape, float scaleFactor, int duration, int repeatCount, boolean reverse) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(shape, "scaleX", scaleFactor);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        if (reverse)
            animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Makes an animator to scale a given shape in the y dimension.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param scaleFactor The target scale factor of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorScaleY(GLShapeCV shape, float scaleFactor, int duration, int repeatCount, boolean reverse) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(shape, "scaleY", scaleFactor);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        if (reverse)
            animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Makes an animator to scale a given shape in the z dimension.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param scaleFactor The target scale factor of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorScaleZ(GLShapeCV shape, float scaleFactor, int duration, int repeatCount, boolean reverse) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(shape, "scaleZ", scaleFactor);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        if (reverse)
            animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Makes an animator to scale a given shape in all three dimension.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param scaleFactor The target scale factor of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorScale(GLShapeCV shape, float scaleFactor, int duration, int repeatCount, boolean reverse) {
        // ObjectAnimator animator = ObjectAnimator.ofFloat(shape, "scale", scaleFactor);
        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(shape,PropertyValuesHolder.ofFloat("scaleX",scaleFactor),
                PropertyValuesHolder.ofFloat("scaleY",scaleFactor),PropertyValuesHolder.ofFloat("scaleZ",scaleFactor));
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        if (reverse)
            animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Makes an animator to let a given shape make a rotation around the x axis of the world coordinate system.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorRotX(GLShapeCV shape, float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        float axis[] = { 1, 0, 0 };
        return GLAnimatorFactoryCV.addAnimatorRot(shape,angleToTraverse,axis,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a given shape make a rotation around the y axis of the world coordinate system.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorRotY(GLShapeCV shape, float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        float axis[] = { 0, 1, 0 };
        return GLAnimatorFactoryCV.addAnimatorRot(shape,angleToTraverse,axis,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a given shape make a rotation around the z axis of the world coordinate system.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorRotZ(GLShapeCV shape, float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        float axis[] = { 0, 0, 1 };
        return GLAnimatorFactoryCV.addAnimatorRot(shape,angleToTraverse,axis,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a given shape make a rotation around a specified axis of the world coordinate system.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param angleToTraverse The rotation angle to traverse.
     * @param axis The rotation axis.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorRot(GLShapeCV shape, float angleToTraverse, float[] axis, int duration, int repeatCount, boolean reverse) {
        EvaluatorRotation eval = new EvaluatorRotation(shape,angleToTraverse,axis);
        float[] dummy = new float[1];
        // ObjectAnimator animator = ObjectAnimator.ofObject(shape,"rotationForAnimator",eval,dummy,dummy);
        ObjectAnimator animator = ObjectAnimator.ofObject(shape,"rotationMatrix",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        if (reverse)
            animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a rotation around an axis in the world coordinate system - see method addAnimatorRot().
     */

    private static class EvaluatorRotation implements TypeEvaluator<float[]> {
        private GLShapeCV shape;
        private float[] startRotMatrix; // rotation matrix of the shape when the rotation starts
        private float angleToTraverse;  // rotation angle to traverse in the animation
        private float[] axis;           // rotation axis of the animation
        private boolean attributeIsValid;

        EvaluatorRotation(GLShapeCV shape, float angleToTraverse, float[] axis) {
            this.shape = shape;
            this.angleToTraverse = angleToTraverse;
            this.axis = axis.clone();
            this.attributeIsValid = false;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                startRotMatrix = shape.getRotationMatrix();
                // for debugging purposes
                // float rotAngleInit = GraphicsUtilsCV.rotAngleFrom4x4RotationMatrix(GraphicsUtilsCV.matrixFromArray(startRotMatrix,4,4));
                // float[] rotAxisInit = GraphicsUtilsCV.rotAxisFrom4x4RotationMatrix(GraphicsUtilsCV.matrixFromArray(startRotMatrix,4,4));
                // Log.v("GLDEMO","AnimatorRot: "+rotAngleInit+"  "+rotAxisInit[0]+" "+rotAxisInit[1]+" "+rotAxisInit[2]);
                attributeIsValid = true;
            }
            float currentRotAngle = f*angleToTraverse;
            // Log.v("GLDEMO","animator: "+currentRotAngle+"  "+axis[0]+" "+axis[1]+" "+axis[2]);
            float[] rotMatrix = new float[16];
            Matrix.setRotateM(rotMatrix,0,currentRotAngle,axis[0],axis[1],axis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            /*
            float[] result = new float[4];
            float[][] rotMatrix2Dim = GraphicsUtilsCV.matrixFromArray(rotMatrix,4,4);
            result[0] = GraphicsUtilsCV.rotAngleFrom4x4RotationMatrix(rotMatrix2Dim);
            float[] tmp = GraphicsUtilsCV.rotAxisFrom4x4RotationMatrix(rotMatrix2Dim);
            result[1] = tmp[0];
            result[2] = tmp[1];
            result[3] = tmp[2];
            return result; */
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a given shape make a rotation to align it with a given vector.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param axisToAlign The axis of the shape to be aligned with vector - 0 = x axis, 1 = y axis, 2 = z axis.
     * @param vectorToAlignWith The vector to align the shape with.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorAlign(GLShapeCV shape, int axisToAlign, float[] vectorToAlignWith, int duration) {
        EvaluatorAlignWithVector eval = new EvaluatorAlignWithVector(shape,axisToAlign,vectorToAlignWith);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject(shape,"rotationMatrix",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
        /*
        float[] shapeAxis = new float[4];
        shapeAxis[axisToAlign] = 1;
        Matrix.multiplyMV(shapeAxis,0,shape.getRotationMatrix(),0,shapeAxis,0);
        float[] shapeAxisShort = new float[3];
        for (int i=0;i<3;i++)
            shapeAxisShort[i] = shapeAxis[i];
        float[] shapeAxisNormalized = GraphicsUtilsCV.getNormalizedCopy(shapeAxisShort);
        float[] alignmentVectorNormalized = GraphicsUtilsCV.getNormalizedCopy(vectorToAlignWith);
        float[] axis = GraphicsUtilsCV.crossProduct(shapeAxisNormalized,alignmentVectorNormalized);
        float angle = (float) (180*Math.acos(GraphicsUtilsCV.dotProduct(shapeAxisNormalized,alignmentVectorNormalized))/Math.PI);
        return GLAnimatorFactoryCV.addAnimatorRot(shape,angle,axis,duration,0,false);
        */
    }

    /**
     * Class that defines a TypeEvaluator to align a shape with a vector.
     */

    private static class EvaluatorAlignWithVector implements TypeEvaluator<float[]> {
        private GLShapeCV shape;
        private float[] startRotMatrix;
        private float[] shapeAxisToAlign;
        private float[] vectorToAlignWith;
        private float[] rotAxis;
        private float rotAngle;
        private boolean attributeIsValid;

        EvaluatorAlignWithVector(GLShapeCV shape, int axisToAlign, float[] vectorToAlignWith) {
            this.shape = shape;
            this.shapeAxisToAlign = new float[4];
            this.shapeAxisToAlign[axisToAlign] = 1;
            this.vectorToAlignWith = vectorToAlignWith.clone();
            this.attributeIsValid = false;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                startRotMatrix = shape.getRotationMatrix();
                // float rotAngleInit = GraphicsUtilsCV.rotAngleFrom4x4RotationMatrix(GraphicsUtilsCV.matrixFromArray(startRotMatrix,4,4));
                // float[] rotAxisInit = GraphicsUtilsCV.rotAxisFrom4x4RotationMatrix(GraphicsUtilsCV.matrixFromArray(startRotMatrix,4,4));
                // Log.v("GLDEMO","AnimatorAlign: "+rotAngleInit+"  "+rotAxisInit[0]+" "+rotAxisInit[1]+" "+rotAxisInit[2]);
                Matrix.multiplyMV(shapeAxisToAlign,0,startRotMatrix,0,shapeAxisToAlign,0);
                float[] shapeAxisShort = new float[3];
                for (int i=0;i<3;i++)
                    shapeAxisShort[i] = this.shapeAxisToAlign[i];
                GraphicsUtilsCV.normalize(shapeAxisShort);
                GraphicsUtilsCV.normalize(vectorToAlignWith);
                rotAxis = GraphicsUtilsCV.crossProduct(shapeAxisShort,vectorToAlignWith);
                rotAngle = (float) (180*Math.acos(GraphicsUtilsCV.dotProduct(shapeAxisShort,vectorToAlignWith))/Math.PI);
                attributeIsValid = true;
            }
            float currentRotAngle = f*rotAngle;
            float[] rotMatrix = new float[16];
            Matrix.setRotateM(rotMatrix,0,currentRotAngle,rotAxis[0],rotAxis[1],rotAxis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a given shape make a rotation to align it
     * (i.e. the orientation of its model coordinate system in world space)
     * with another shape (i.e. with the model coordinate system of that shape).
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param shapeToAlignWith The other shape to which the shape shall be aligned.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorAlign(GLShapeCV shape, GLShapeCV shapeToAlignWith, int duration) {
        EvaluatorAlignWithShape eval = new EvaluatorAlignWithShape(shape,shapeToAlignWith);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject(shape,"rotationMatrix",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator to align a shape with another shape.
     */

    private static class EvaluatorAlignWithShape implements TypeEvaluator<float[]> {
        private GLShapeCV shape;
        private GLShapeCV shapeToAlignWith;
        private float[] startRotMatrix;
        private float[] vectorToAlignWith;
        private float[] rotAxis;
        private float rotAngle;
        private boolean attributeIsValid;

        EvaluatorAlignWithShape(GLShapeCV shape,GLShapeCV shapeToAlignWith) {
            this.shape = shape;
            this.shapeToAlignWith = shapeToAlignWith;
            this.attributeIsValid = false;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                startRotMatrix = shape.getRotationMatrix();
                float[] rotMatrix1 = shapeToAlignWith.getRotationMatrix();
                float[] rotMatrix2 = shape.getRotationMatrix();
                float[] inversRotMatrix = new float[16];
                Matrix.invertM(inversRotMatrix, 0, rotMatrix2, 0);
                float[] animRotMatrix = new float[16];
                Matrix.multiplyMM(animRotMatrix, 0, rotMatrix1, 0, inversRotMatrix, 0);
                float[][] animRotMatrix2D = GraphicsUtilsCV.matrixFromArray(animRotMatrix, 4, 4);
                rotAngle = -GraphicsUtilsCV.rotAngleFrom4x4RotationMatrix(animRotMatrix2D);
                rotAxis = GraphicsUtilsCV.rotAxisFrom4x4RotationMatrix(animRotMatrix2D);
                attributeIsValid = true;
            }
            float currentRotAngle = f*rotAngle;
            float[] rotMatrix = new float[16];
            Matrix.setRotateM(rotMatrix,0,currentRotAngle,rotAxis[0],rotAxis[1],rotAxis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a given shape rotate around its own x axis,
     * i.e. the axis in its model coordinate space.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorRotXInModelSpace(GLShapeCV shape, float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        return addAnimatorRotationInModelSpace(shape,0,angleToTraverse,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a given shape rotate around its own y axis,
     * i.e. the axis in its model coordinate space.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorRotYInModelSpace(GLShapeCV shape, float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        return addAnimatorRotationInModelSpace(shape,1,angleToTraverse,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a given shape rotate around its own z axis,
     * i.e. the axis in its model coordinate space.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorRotZInModelSpace(GLShapeCV shape, float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        return addAnimatorRotationInModelSpace(shape,2,angleToTraverse,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a given shape rotate around its own x, y, or z axis,
     * i.e. the axis in its model coordinate space.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param axisId The rotation axis - 0 = x, 1 = y, 2 = z.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    private static ObjectAnimator addAnimatorRotationInModelSpace(GLShapeCV shape, int axisId, float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        EvaluatorRotationInModelSpace eval = new EvaluatorRotationInModelSpace(shape,axisId,angleToTraverse);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject(shape,"rotationMatrix",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a rotation around the x, y, or z axis in the model coordinate system.
     */

    private static class EvaluatorRotationInModelSpace implements TypeEvaluator<float[]> {
        private GLShapeCV shape;
        private int axisId; // 0 = x axis, 2 = y axis, 3 = z axis
        private float[] startRotMatrix; // rotation matrix of the shape when the rotation starts
        float axis[] = new float[4]; // axis in the world coordinate space around which the shape is rotated,
                                     // results from rotating the shape-specific x, z, or y axis by startRotMatrix
        private float angleToTraverse;
        private boolean attributeIsValid;

        EvaluatorRotationInModelSpace(GLShapeCV shape, int axisId, float angleToTraverse) {
            this.shape = shape;
            this.angleToTraverse = angleToTraverse;
            this.axisId = axisId;
            this.attributeIsValid = false;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                startRotMatrix = shape.getRotationMatrix();
                attributeIsValid = true;
                // calculate the rotated x, z, or y axis
                float[] axisPoint1 = {0,0,0,1}, axisPoint2 = {0,0,0,1};
                axisPoint2[axisId] = 1;
                Matrix.multiplyMV(axisPoint1,0,startRotMatrix,0,axisPoint1,0);
                Matrix.multiplyMV(axisPoint2,0,startRotMatrix,0,axisPoint2,0);
                for (int i=0;i<4;i++)
                    axis[i] = axisPoint1[i]-axisPoint2[i];
            }
            float currentAngle = f*angleToTraverse;
            float[] rotMatrix = new float[16];
            Matrix.setRotateM(rotMatrix,0,currentAngle,axis[0],axis[1],axis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a given shape "pitch", i.e. move up and down rotating around its x axis.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param maxAngle The maximum angle by which the object is moved up or down.
     * @param duration The duration of a full round (= movement of the shape in both directions and return to the start position).
     * @param repeatCount The number of times the animation shall be repeated.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorPitch(GLShapeCV shape, float maxAngle, int duration, int repeatCount) {
        return addAnimatorPitchRollYaw(0,shape,maxAngle,duration,repeatCount);
    }

    /**
     * Makes an animator to let a given shape "roll" around its z axis.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param maxAngle The maximum angle by which the object is roll.
     * @param duration The duration of a full round (= movement of the shape in both directions and return to the start position).
     * @param repeatCount The number of times the animation shall be repeated.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorRoll(GLShapeCV shape, float maxAngle, int duration, int repeatCount) {
        return addAnimatorPitchRollYaw(1,shape,maxAngle,duration,repeatCount);
    }

    /**
     * Makes an animator to let a given shape "yaw", i.e. move left and right rotating around its y axis.
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shape The shape to be animated.
     * @param maxAngle The maximum angle by which the object is moved left or right.
     * @param duration The duration of a full round (= movement of the shape in both directions and return to the start position).
     * @param repeatCount The number of times the animation shall be repeated.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorYaw(GLShapeCV shape, float maxAngle, int duration, int repeatCount) {
        return addAnimatorPitchRollYaw(2,shape,maxAngle,duration,repeatCount);
    }

    /**
     * Makes an animator to let a given shape pitch, roll, or yaw
     * Adds the new animator to the animators of the shape.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param type The type of the movement - 0 = pitch, 1 = roll, 2 = yaw.
     * @param shape The shape to be animated.
     * @param maxAngle The maximum angle by which the object is moved.
     * @param duration The duration of a full round (= movement of the shape in both directions and return to the start position).
     * @param repeatCount The number of times the animation shall be repeated.
     * @return The newly generated animator.
     */

    private static ObjectAnimator addAnimatorPitchRollYaw(int type, GLShapeCV shape, float maxAngle, int duration, int repeatCount) {
        EvaluatorPitchRollYaw eval = new EvaluatorPitchRollYaw(shape,maxAngle,type);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject(shape,"rotationMatrix",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a pitch, roll, or yaw animation.
     */

    private static class EvaluatorPitchRollYaw implements TypeEvaluator<float[]> {
        private GLShapeCV shape;
        private int type; // 0 = pitch, 1 = roll, 2 = yaw
        private float[] startRotMatrix; // rotation matrix of the shape when the rotation starts
        float axis[] = new float[4]; // axis world coordinate space around which the shape is pitched, rolled, or yawed;
                                     // results from rotating the shape-specific x, z, or y axis by startRotMatrix
        private float maxAngle;  // maximum angle by which the shape shall be moved
        private boolean attributeIsValid;

        EvaluatorPitchRollYaw(GLShapeCV shape, float maxAngle, int type) {
            this.shape = shape;
            this.maxAngle = maxAngle;
            this.type = type;
            this.attributeIsValid = false;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                startRotMatrix = shape.getRotationMatrix();
                attributeIsValid = true;
                // calculate the rotated x, z, or y axis
                float[] axisPoint1 = {0,0,0,1}, axisPoint2 = {0,0,0,1};
                switch (type) {
                    case 0: axisPoint2[0] = 1; break; // pitch = rotation around x axis
                    case 1: axisPoint2[2] = 1; break; // roll = rotation around z axis
                    case 2: axisPoint2[1] = 1; break; // yaw = rotation around y axis
                }
                Matrix.multiplyMV(axisPoint1,0,startRotMatrix,0,axisPoint1,0);
                Matrix.multiplyMV(axisPoint2,0,startRotMatrix,0,axisPoint2,0);
                for (int i=0;i<4;i++)
                    axis[i] = axisPoint1[i]-axisPoint2[i];
            }
            float currentAngle;
            if (f<0.25)
                currentAngle = -f*4*maxAngle;
            else if (f<0.5)
                currentAngle = -maxAngle+(f-.25f)*4*maxAngle;
            else if (f<0.75)
                currentAngle = (f-.5f)*4*maxAngle;
            else
                currentAngle = maxAngle-(f-0.75f)*4*maxAngle;
            float[] rotMatrix = new float[16];
            // pitch, roll, or yaw around the rotated x, z, or y matrix
            Matrix.setRotateM(rotMatrix,0,currentAngle,axis[0],axis[1],axis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a given shape move on a direct line to a specific x position.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param targetX The target x position of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated. If repeatCount is greater than 1, the animation is reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorTransX(GLShapeCV shape, float targetX, int duration, int repeatCount) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(shape, "transX", targetX);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Makes an animator to let a given shape move on a direct line to a specific y position.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param targetY The target y position of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated. If repeatCount is greater than 1, the animation is reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorTransY(GLShapeCV shape, float targetY, int duration, int repeatCount) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(shape, "transY", targetY);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Makes an animator to let a given shape move on a direct line to a specific z position.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param targetZ The target z position of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated. If repeatCount is greater than 1, the animation is reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorTransZ(GLShapeCV shape, float targetZ, int duration, int repeatCount) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(shape, "transZ", targetZ);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Makes an animator to let a given shape move on a direct line to a specific (x,y,z) position.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param targetX The target x position of the animation.
     * @param targetY The target y position of the animation.
     * @param targetZ The target z position of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated. If repeatCount is greater than 1, the animation is reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator addAnimatorTrans(GLShapeCV shape, float targetX, float targetY, float targetZ, int duration, int repeatCount) {
        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(shape,PropertyValuesHolder.ofFloat("transX",targetX),
                PropertyValuesHolder.ofFloat("transY",targetY),PropertyValuesHolder.ofFloat("transZ",targetZ));
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Makes an animator to let a given shape move on a direct line to a specific (x,y,z) position.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param target The target  position of the animation.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated. If repeatCount is greater than 1, the animation is reversed.
     * @return The newly generated animator or null if the target parameter is not valid, i.e. not an array of length 3.
     */

    public static ObjectAnimator addAnimatorTrans(GLShapeCV shape, float[] target, int duration, int repeatCount) {
        if (target==null||target.length!=3) return null;
        return addAnimatorTrans(shape,target[0],target[1],target[2],duration,repeatCount);
    }

    /**
     * Makes animators to place a shape between two given points, i.e. to translate and to rotate it and (optionally) to scale it.
     * The y axis of the object is rotated, i.e. will afterwards be in line with the two points.
     * Adds the new animators to the animators of the shape.
     * @param shape The shape to be animated.
     * @param point1 The first point.
     * @param point1 The second point.
     * @param scaleX The target scaling factor for the x dimension.
     * @param scaleY The target scaling factor for the y dimension.
     * @param scaleZ The target scaling factor for the z dimension.
     * @param duration The duration of the animation (ms).
     * @return An ArrayList with the animators.
     */

    public static ArrayList<ObjectAnimator> addAnimatorPlaceBetween(GLShapeCV shape, float[] point1, float[] point2, float scaleX, float scaleY, float scaleZ, int duration) {
        if (point1==null||point1.length!=3||point2==null||point2.length!=3||Math.abs(shape.getIntrinsicSizeY())<1E-5) return null;
        float y_axis[] = {0,1,0};
        float[] midpoint = GraphicsUtilsCV.midpoint(point1,point2);
        float vectorBetweenPoints[] = GraphicsUtilsCV.vectorBetweenPoints(point1,point2);
        /* Lösung mit ofMultiFloat(), die aber nicht funktioniert
        ObjectAnimator animator;
        // Log.v("GLDEMO","addAnimatorPlaceBetween for "+shape.getId());
        if (Math.abs(vectorBetweenPoints[0])>10e-5||Math.abs(vectorBetweenPoints[2])>10e-5) {
            // rotate only if the rotation axis is not parallel to the y axis
            float rotAxis[] = GraphicsUtilsCV.crossProduct(y_axis, vectorBetweenPoints);
            float rotAngle = (float) Math.toDegrees(Math.acos(GraphicsUtilsCV.dotProduct(y_axis, GraphicsUtilsCV.getNormalizedCopy(GraphicsUtilsCV.vectorBetweenPoints(point1, point2)))));
            float[][] animatorRotParam = new float[2][4];
            animatorRotParam[0][0] = shape.getRotAngle();
            // Log.v("GLDEMO","start angle: "+animatorRotParam[0][0]);
            animatorRotParam[1][0] = shape.getRotAngle()+rotAngle;
            // Log.v("GLDEMO","target angle: "+animatorRotParam[1][0]);
            animatorRotParam[0][1] = animatorRotParam[1][1] = rotAxis[0];
            animatorRotParam[0][2] = animatorRotParam[1][2] = rotAxis[1];
            animatorRotParam[0][3] = animatorRotParam[1][3] = rotAxis[2];
            animator = ObjectAnimator.ofPropertyValuesHolder(shape,
                    PropertyValuesHolder.ofFloat("scaleX", scaleX),
                    PropertyValuesHolder.ofFloat("scaleY", scaleY),
                    PropertyValuesHolder.ofFloat("scaleZ", scaleZ),
                    // bug: setRotationForAnimator() is not called.
                    PropertyValuesHolder.ofMultiFloat("rotationForAnimator", animatorRotParam),
                    PropertyValuesHolder.ofFloat("transX", midpoint[0]),
                    PropertyValuesHolder.ofFloat("transY", midpoint[1]),
                    PropertyValuesHolder.ofFloat("transZ", midpoint[2]));
        } else {
            // Log.v("GLDEMO","addAnimatorPlaceBetween for "+shape.getId()+" - else");
            animator = ObjectAnimator.ofPropertyValuesHolder(shape,
                    PropertyValuesHolder.ofFloat("scaleX", scaleX),
                    PropertyValuesHolder.ofFloat("scaleY", scaleY),
                    PropertyValuesHolder.ofFloat("scaleZ", scaleZ),
                    PropertyValuesHolder.ofFloat("transX", midpoint[0]),
                    PropertyValuesHolder.ofFloat("transY", midpoint[1]),
                    PropertyValuesHolder.ofFloat("transZ", midpoint[2]));
        }
        animator.setDuration(duration);
        shape.addAnimator(animator);
        return animator;
        */
        /* Alternativ: Einzelanimatoren */
        ArrayList<ObjectAnimator> animators = new ArrayList<>();
        if (Math.abs(vectorBetweenPoints[0])>10e-5||Math.abs(vectorBetweenPoints[2])>10e-5) {
                // rotate only if the rotation axis is not parallel to the y axis
                float rotAxisForShape[] = GraphicsUtilsCV.crossProduct(y_axis, vectorBetweenPoints);
                float rotAngleForShape = (float) Math.toDegrees(Math.acos(GraphicsUtilsCV.dotProduct(y_axis, GraphicsUtilsCV.getNormalizedCopy(GraphicsUtilsCV.vectorBetweenPoints(point1, point2)))));
                animators.add(GLAnimatorFactoryCV.addAnimatorRot(shape,rotAngleForShape,rotAxisForShape,duration,0,false));
        }
        animators.add(GLAnimatorFactoryCV.addAnimatorScaleX(shape,scaleX,duration,0,false));
        animators.add(GLAnimatorFactoryCV.addAnimatorScaleY(shape,scaleY,duration,0,false));
        animators.add(GLAnimatorFactoryCV.addAnimatorScaleZ(shape,scaleZ,duration,0,false));
        animators.add(GLAnimatorFactoryCV.addAnimatorTrans(shape,midpoint,duration,0));
        return animators;
    }

    /**
     * Makes an animator to move a given shape along an arc around an axis that is specified by two points in 3D space.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param axisPoint1 The first point defining the axis.
     * @param axisPoint2 The second point defining the axis.
     * @param angle The angle of the arc to be traversed.
     * @param duration The duration of the animation (in ms).
     * @param startDelay The start delay of the animation (in ms).
     * @return The new animator
     */

    public static ObjectAnimator addAnimatorArcPathAroundAxis(GLShapeCV shape, float[] axisPoint1, float[] axisPoint2, float angle, int duration, int startDelay) {
/*
        EvaluatorArcPathAroundAxis eval = new EvaluatorArcPathAroundAxis(shape,axisPoint1,axisPoint2,angle);
        float[] dummy = new float[3];
        ObjectAnimator anim = ObjectAnimator.ofObject(shape,"trans",eval,dummy,dummy);
        anim.setDuration(duration);
        anim.setStartDelay(startDelay);
        shape.addAnimator(anim);
        return anim;
 */
        return addAnimatorSpiralPath(shape,axisPoint1,axisPoint2,angle/360,0,duration,startDelay);
    }

    /**
     * Class that defines a TypeEvaluator for a movement along an arc around an axis - see method addAnimatorArcPathAroundAxis().
     */

    private static class EvaluatorArcPathAroundAxis implements TypeEvaluator<float[]> {
        GLShapeCV shape;  // shape to be animated
        float[] axisPoint1;  // first point on the axis
        float[] axisPoint2;  // second point on the axis
        double angle;  // angle of the arc to traverse
        float[] start;  // start position of the shape
        boolean attributeIsValid;

        // The start position of the animated shape is stored when the animation starts.
        // 'attributeIsValid' specifies if this has been done already.
        EvaluatorArcPathAroundAxis(GLShapeCV shape, float[] axisPoint1, float[] axisPoint2, double angle) {
            this.shape = shape;
            this.axisPoint1 = axisPoint1.clone();
            this.axisPoint2 = axisPoint2.clone();
            this.angle = angle;
            this.attributeIsValid = false;
        }

        public float[] evaluate(float f, float dummy1[], float[] dummy2) {
            if (!attributeIsValid) {
                start = shape.getTrans();
                attributeIsValid = true;
            }
            float[] retval = GraphicsUtilsCV.rotateAroundAxis(start,axisPoint1,axisPoint2,(float)(f*angle));
            return retval;
        }

    }

    /**
     * Makes an animator to move a given shape in a spiral around an axis. The axis is specified by two points in 3D space.
     * Adds the new animator to the animators of the shape.
     * @param shape The shape to be animated.
     * @param axisPoint1 The first point defining the axis.
     * @param axisPoint2 The second point defining the axis.
     * @param turns The number of turns to be made around the axis. If negative, the rotation is clockwise.
     * @param height The height of the spiral.
     * @param duration The duration of the animation (in ms).
     * @param startDelay The start delay of the animation (in ms).
     * @return The new animator
     */

    public static ObjectAnimator addAnimatorSpiralPath(GLShapeCV shape, float[] axisPoint1, float[] axisPoint2, float turns, float height, int duration, int startDelay) {
        EvaluatorSpiralPath eval = new EvaluatorSpiralPath(shape,axisPoint1,axisPoint2,turns,height);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject(shape,"trans",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setStartDelay(startDelay);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a movement along a spiral around an axis - see method addAnimatorSpiralPath().
     */

    private static class EvaluatorSpiralPath implements TypeEvaluator<float[]> {
        GLShapeCV shape;  // shape to be animated
        float[] axisPoint1;  // first point on the axis
        float[] axisPoint2;  // second point on the axis
        float[] normedAxisVector; // a vector defining the axis with length 'height'
        float angle;  // angle of the arc to traverse
        float[] start;  // start position of the shape
        boolean attributeIsValid;

        // The start position of the animated shape is stored when the animation starts.
        // 'attributeIsValid' specifies if this has been done already.
        EvaluatorSpiralPath(GLShapeCV shape, float[] axisPoint1, float[] axisPoint2, float turns, float height) {
            this.shape = shape;
            this.axisPoint1 = axisPoint1.clone();
            this.axisPoint2 = axisPoint2.clone();
            this.angle = turns*360;
            normedAxisVector = new float[3];
            float dist = GraphicsUtilsCV.distance(axisPoint1,axisPoint2);
            if (dist!=0)
                for (int i=0; i<3; i++)
                    normedAxisVector[i] = (axisPoint2[i]-axisPoint1[i])*height/dist;
            this.attributeIsValid = false;
        }

        public float[] evaluate(float f, float dummy1[], float[] dummy2) {
            if (!attributeIsValid) {
                start = shape.getTrans();
                attributeIsValid = true;
            }
            float[] retval = GraphicsUtilsCV.rotateAroundAxis(start,axisPoint1,axisPoint2,f*angle);
            for (int i=0; i<3; i++)
                retval[i] += f*normedAxisVector[i];
            return retval;
        }

    }

    /** Add an animator to move the object along a quadratic Bezier curve.
     *
     * @param control control point
     * @param target target point
     * @param duration Duration of the animation (in ms)
     * @param startDelay Start delay of the animation (in ms)
     * @return The new animator
     */

    public static ObjectAnimator addAnimatorBezierPath(GLShapeCV shape, float[] control, float[] target, int duration, int startDelay) {
        return addAnimatorBezierPath(shape,control,target,-1,duration,startDelay);
    }

    /** Add an animator to move the object along a quadratic Bezier curve.
     *
     * @param control control point
     * @param target target point
     * @param axisToAlign specifies if the shape shall be aligned with its current movement direction:
     *                    -1 = no alignment, 0/1/2 = alignment of the shape's x/y/z axis
     * @param duration Duration of the animation (in ms)
     * @param startDelay Start delay of the animation (in ms)
     * @return The new animator
     */

    public static ObjectAnimator addAnimatorBezierPath(GLShapeCV shape, float[] control, float[] target, int axisToAlign, int duration, int startDelay) {
        BezierEvaluator eval = new BezierEvaluator(shape,control,axisToAlign);
        ObjectAnimator animator = ObjectAnimator.ofObject(shape,"trans",eval,shape.getTrans(),target);
        animator.setDuration(duration);
        animator.setStartDelay(startDelay);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /** Add an animator to move the object along a cubic Bezier curve.
     *
     * @param control1 first control point
     * @param control2 second control point
     * @param target target point
     * @param duration Duration of the animation (in ms)
     * @param startDelay Start delay of the animation (in ms)
     * @return The new animator
     */

    public static ObjectAnimator addAnimatorBezierPath(GLShapeCV shape, float[] control1, float[] control2, float[] target, int duration, int startDelay) {
        return addAnimatorBezierPath(shape,control1,control2,target,-1,duration,startDelay);
    }

    /** Add an animator to move the object along a cubic Bezier curve.
     *
     * @param control1 first control point
     * @param control2 second control point
     * @param target target point
     * @param axisToAlign specifies if the shape shall be aligned with its current movement direction:
     *                    -1 = no alignment, 0/1/2 = alignment of the shape's x/y/z axis
     * @param duration Duration of the animation (in ms)
     * @param startDelay Start delay of the animation (in ms)
     * @return The new animator
     */

    public static ObjectAnimator addAnimatorBezierPath(GLShapeCV shape, float[] control1, float[] control2, float[] target, int axisToAlign, int duration, int startDelay) {
        BezierEvaluator eval = new BezierEvaluator(shape,control1,control2,axisToAlign);
        ObjectAnimator animator = ObjectAnimator.ofObject(shape,"trans",eval,shape.getTrans(),target);
        animator.setDuration(duration);
        animator.setStartDelay(startDelay);
        animator.setInterpolator(new LinearInterpolator());
        shape.addAnimator(animator);
        return animator;
    }

    /** Class that defines a TypeEvaluator for a movement along a Bezier curve of order 2 or 3 - see method addAnimatorBezierPath().
     */

    private static class BezierEvaluator implements TypeEvaluator<float[]> {

        GLShapeCV shape; // the shape to be animated

        private int order; // order of the Bezier curve: 2 = quadratic, 3 = cubic; all other values are undefined */

        /** first control point */

        private float[] contr1;

        /** second control point */

        private float[] contr2;

        /** position of the shape when the animation starts */

        private float[] start;

        /** the last position of the shape */

        private float[] lastPos;

        private int axisToAlign = -1;

        /** Constructor for a quadratic Bezier curve
         *
         * @param contr1 Control point of the curve
         */

        BezierEvaluator(GLShapeCV shape, float[] contr1, int axisToAlign) {
            this.start = null;
            this.shape = shape;
            this.contr1 = contr1.clone();
            this.order = 2;
            this.axisToAlign = axisToAlign;
        }

        /** Constructor for a cubic Bezier curve
         *
         * @param contr1 First control point of the curve
         * @param contr2 Second control point of the curve
         */

        BezierEvaluator(GLShapeCV shape, float[] contr1, float[] contr2, int axisToAlign) {
            this.start = null;
            this.shape = shape;
            this.contr1 = contr1.clone();
            this.contr2 = contr2.clone();
            this.order = 3;
            this.axisToAlign = axisToAlign;
        }

        /** Evaluator */

        public float[] evaluate(float f, float[] dummy, float[] target) {
            float[] result = new float[3];
            if (start==null) {
                start = shape.getTrans();
                lastPos = start;
            }
            if (order==2) {
                result[0] = ((start[0] - 2 * contr1[0] + target[0]) * f * f + (-2 * start[0] + 2 * contr1[0]) * f + start[0]);
                result[1] = ((start[1] - 2 * contr1[1] + target[1]) * f * f + (-2 * start[1] + 2 * contr1[1]) * f + start[1]);
                result[2] = ((start[2] - 2 * contr1[2] + target[2]) * f * f + (-2 * start[2] + 2 * contr1[2]) * f + start[2]);
            }
            if (order==3) {
                result[0] = (1 - f) * (1 - f) * (1 - f) * start[0] + 3 * (1 - f) * (1 - f) * f * contr1[0] + 3 * (1 - f) * f * f * contr2[0] + f * f * f * target[0];
                result[1] = (1 - f) * (1 - f) * (1 - f) * start[1] + 3 * (1 - f) * (1 - f) * f * contr1[1] + 3 * (1 - f) * f * f * contr2[1] + f * f * f * target[1];
                result[2] = (1 - f) * (1 - f) * (1 - f) * start[2] + 3 * (1 - f) * (1 - f) * f * contr1[2] + 3 * (1 - f) * f * f * contr2[2] + f * f * f * target[2];
            }
            if (axisToAlign>=0 && GraphicsUtilsCV.distance(lastPos,result)>0.2) {
                float vector[] = new float[3];
                for (int i=0;i<3;i++)
                    vector[i] = result[i]-lastPos[i];
                shape.alignWith(axisToAlign,vector,0,0,0);
                lastPos = result.clone();
            }
            return result;
        }

    }

    /**
     * Class for listeners that shall be executed when an animation ends
     * and that will remove the animated shape from the surface view.
     */

    public static class EndListenerRemove extends AnimatorListenerAdapter {
        private GLShapeCV shape;
        private GLSurfaceViewCV surfaceView;
        public EndListenerRemove(GLShapeCV shape, GLSurfaceViewCV surfaceView) {
            this.shape = shape;
            this.surfaceView = surfaceView;
        }
        @Override
        public void onAnimationEnd(Animator animator) {
            surfaceView.removeShape(shape);
        }
    }

  /*
    public static ObjectAnimator makeAnimatorTrans(GLShapeCV shape, float[] transStart, float[] transEnd, int duration, int repeatCount) {

        // MIT ofMultiFloat FUNKTIONIERT ES NICHT: DER LISTENER RUFT DIE METHODE setTrans() NICHT AUF

        // Log.v("DEMO","makeAnimatorTrans: "+transStart[0]+" "+transStart[1]+" "+transStart[2]+" "+transEnd[0]+" "+transEnd[1]+" "+transEnd[2]);

        float startEnd[][] = new float[2][];
        startEnd[0] = transStart;
        startEnd[1] = transEnd;
        // ObjectAnimator animator = ObjectAnimator.ofMultiFloat(shape, "trans", startEnd);

        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(shape,PropertyValuesHolder.ofFloat("transX",2),
                PropertyValuesHolder.ofFloat("transY",10),PropertyValuesHolder.ofFloat("transZ",-10));

        // ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(shape,PropertyValuesHolder.ofFloat("transZ",-4));
        animator.setDuration(duration);

        // animator.setRepeatCount(repeatCount);
        // animator.setRepeatMode(ValueAnimator.REVERSE);
        // Log.v("DEMO","makeAnimatorTrans: "+startEnd[0][0]+" "+startEnd[0][1]+" "+startEnd[0][2]+"  "+startEnd[1][0]+" "+startEnd[1][1]+" "+startEnd[1][2]+" ");
        return animator;
    }

   */

}
